<!DOCTYPE html>
<html>
  <head>
    <title>GLTF Loader Test</title>
    <link rel="stylesheet" href="./testing-e2e/styles/tachyons.min.css" />
    <link rel="stylesheet" href="./testing-e2e/styles/main.css" />
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-engine/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-engine/dist/plugins.umd.js"></script>

    <script src="https://www.gstatic.com/draco/v1/decoders/draco_decoder_gltf.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/gltf-loader/dist/index.umd.js"></script>
    <style>
      body {
        height: 100vh;
        overflow: hidden;
        margin: 0em;
      }
      #canvas {
        position: relative;
        height: 100%;
        width: 100%;
      }
      .fps-display {
        position: fixed;
        bottom: 10px;
        right: 10px;
        color: #333333;
      }
      .progress-display {
        position: fixed;
        left: 0px;
        bottom: 0px;
        width: 100%;
        height: 10px;
      }
      .hidden {
        visibility: hidden;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="fps-display" id="fps"></div>
    <progress class="progress-display" id="progress" value="0" max="100">0%</progress>

    <script type="module">
      const {
        GLRenderer,
        Scene,
        Vec3,
        Xfo,
        Color,
        Sphere,
        Material,
        GeomItem,
        GLBoundingBoxPass,
        EnvMap,
        resourceLoader,
      } = zeaEngine

      const scene = new Scene()
      const renderer = new GLRenderer(document.getElementById('canvas'), { hideSplash: true, xrCompatible: false })
      renderer.setScene(scene)

      const envMap = new EnvMap()
      envMap.getParameter('FilePath').setValue('./testing-e2e/data/pisa.zenv')
      scene.setEnvMap(envMap)
      scene.getSettings().getParameter('Display EnvMap').setValue(false)
      renderer.exposure = 1.2
      renderer.getViewport().getCamera().setPositionAndTarget(new Vec3(3, -3, 1.7), new Vec3(0, 0, 0.1))

      // /////////////////////////////////////
      // Setup a Bounding Box pass to display all
      // the bounding boxes of the items in the scene.
      // const boundingBoxPass = new GLBoundingBoxPass()
      // renderer.addPass(boundingBoxPass)
      // boundingBoxPass.addTreeItem(scene.getRoot(), true)

      // /////////////////////////////////////
      // Setup the custom classes
      // The custom pass to handle rendering, and add a custom
      // TreeItem to the scene tree
      const { GLTFAsset } = gltfLoader

      const urlParams = new URLSearchParams(window.location.search)
      if (urlParams.has('gltf')) {
        const asset = new GLTFAsset('gltf')
        asset.loadGltf(urlParams.get('gltf')).then(() => {
          console.log('Loading done')

          const xfo = new Xfo() //asset.getParameter('LocalXfo').getValue()
          if (urlParams.has('y2zup')) {
            xfo.ori.setFromAxisAndAngle(new Vec3(1, 0, 0), Math.PI * 0.5)
          }
          const box = asset.getParameter('BoundingBox').getValue()
          xfo.tr.z = -box.p0.z
          asset.getParameter('LocalXfo').setValue(xfo)

          const diagonal = box.p1.subtract(box.p0)
          diagonal.z = 0
          scene.setupGrid(diagonal.length() * 2, 10)

          renderer.frameAll()
        })
        scene.getRoot().addChild(asset)
      }

      // /////////////////////////////////////
      // Check that pointer interactions work.
      let highlighted
      renderer.getViewport().on('pointerMove', (event) => {
        if (event.intersectionData) {
          const { geomItem, dist } = event.intersectionData
          if (geomItem != highlighted) {
            if (highlighted) highlighted.removeHighlight('custom')
            highlighted = geomItem
            highlighted.addHighlight('custom', new Color(0, 1, 0, 0.1))
          }
        } else {
          if (highlighted) highlighted.removeHighlight('custom')
          highlighted = null
        }
      })

      // /////////////////////////////////////

      let frameCounter = 0
      let fps = 0
      renderer.on('redrawOccurred', () => {
        frameCounter++
      })
      const fpsElement = document.getElementById('fps')
      setInterval(() => {
        if (fps != frameCounter * 2) {
          fps = frameCounter * 2
          fpsElement.textContent = `FPS: ${fps}`
        }
        frameCounter = 0
      }, 500)
      // /////////////////////////////////////

      resourceLoader.on('progressIncremented', (event) => {
        const pct = document.getElementById('progress')
        pct.value = event.percent
        if (event.percent >= 100) {
          setTimeout(() => pct.classList.add('hidden'), 1000)
        }
      })
    </script>
  </body>
</html>
